/**
 * AFI Mint Pipeline Driver
 * =========================
 * 
 * This module defines the abstraction for how AFI-Core hands off mint instructions
 * to the AFI-Token layer (AFIMintCoordinator) without making direct on-chain calls.
 * 
 * CURRENT STATUS: Pure abstraction with type definitions only.
 * 
 * IMPORTANT: This module does NOT import or use ethers, viem, or any Base RPC clients.
 * It is a **pure abstraction** that defines the interface for mint instruction generation.
 * 
 * FUTURE WORK:
 * - On testnet: Implement a staging backend or local mock
 * - On mainnet: Integrate with Safe / backend / droid that calls AFIMintCoordinator
 * 
 * @module runtime/mintPipelineDriver
 * @see docs/AFI_CORE_RUNTIME_OVERVIEW.md
 */

// ============================================================================
// Type Definitions
// ============================================================================

/**
 * Mint instruction generated by AFI-Core.
 * This is the structured output that will be sent to the token layer.
 */
export interface AFIMintInstruction {
  /** Unique identifier for this mint instruction */
  instructionId: string;
  
  /** Signal ID that triggered this mint */
  signalId: string;
  
  /** Amount of AFI tokens to mint (in wei or smallest unit) */
  amount: string;
  
  /** Recipient address for the minted tokens */
  recipient: string;
  
  /** Proof-of-Intelligence score (0-100) */
  poiScore: number;
  
  /** Confidence level (0-1) */
  confidence: number;
  
  /** Validator signatures or proof data */
  proof?: {
    /** Validator addresses that approved this mint */
    validators: string[];
    
    /** Signatures from validators (if applicable) */
    signatures?: string[];
    
    /** Additional proof metadata */
    metadata?: Record<string, unknown>;
  };
  
  /** Timestamp when this instruction was generated */
  createdAt: string;
  
  /** Additional metadata */
  metadata?: Record<string, unknown>;
}

/**
 * Preview of the impact of a mint instruction.
 * Used for dry-run / simulation before actual minting.
 */
export interface AFIMintPreview {
  /** Instruction being previewed */
  instruction: AFIMintInstruction;
  
  /** Estimated gas cost (in wei) */
  estimatedGas?: string;
  
  /** Current AFI token supply */
  currentSupply?: string;
  
  /** New supply after mint */
  newSupply?: string;
  
  /** Whether this mint would exceed the supply cap */
  exceedsSupplyCap: boolean;
  
  /** Whether this mint is valid according to current rules */
  isValid: boolean;
  
  /** Validation errors (if any) */
  errors?: string[];
  
  /** Warnings (if any) */
  warnings?: string[];
}

/**
 * Status of a mint instruction in the pipeline.
 */
export type MintInstructionStatus = 
  | 'queued'       // Instruction queued for approval
  | 'approved'     // Approved by backend/Safe, ready for execution
  | 'executing'    // Currently being executed on-chain
  | 'completed'    // Successfully minted on-chain
  | 'failed'       // Execution failed
  | 'rejected';    // Rejected by backend/Safe

/**
 * Mint instruction with status tracking.
 */
export interface AFIMintInstructionWithStatus extends AFIMintInstruction {
  /** Current status of this instruction */
  status: MintInstructionStatus;
  
  /** Transaction hash (if executed on-chain) */
  txHash?: string;
  
  /** Block number (if executed on-chain) */
  blockNumber?: number;
  
  /** Error message (if failed or rejected) */
  error?: string;
  
  /** Status history */
  statusHistory?: Array<{
    status: MintInstructionStatus;
    timestamp: string;
    note?: string;
  }>;
}

// ============================================================================
// AFI Mint Pipeline Driver Interface
// ============================================================================

/**
 * AFI Mint Pipeline Driver
 * 
 * This interface defines how AFI-Core generates and queues mint instructions
 * for the AFI-Token layer.
 * 
 * IMPLEMENTATION STATUS: Interface only. Future work will implement these methods.
 * 
 * IMPORTANT: Implementations must NOT make direct RPC calls or on-chain writes.
 * Instead, they should queue instructions for backend/Safe/droid approval and execution.
 * 
 * @interface AFIMintPipelineDriver
 */
export interface AFIMintPipelineDriver {
  /**
   * Queue a mint instruction for approval and execution.
   * 
   * TODO: Implement queueing logic:
   * - Validate instruction structure
   * - Store in queue (database, message queue, etc.)
   * - Notify backend/Safe for approval
   * - Log to T.S.S.D. Vault for audit
   * 
   * @param instruction - Mint instruction to queue
   * @returns Instruction with status tracking
   */
  queueMintInstruction(instruction: AFIMintInstruction): Promise<AFIMintInstructionWithStatus>;
  
  /**
   * Preview the impact of a mint instruction without executing it.
   * 
   * TODO: Implement preview logic:
   * - Simulate mint on testnet fork
   * - Check supply cap and validation rules
   * - Estimate gas costs
   * - Return preview with warnings/errors
   * 
   * @param instruction - Mint instruction to preview
   * @returns Preview of mint impact
   */
  previewMintImpact(instruction: AFIMintInstruction): Promise<AFIMintPreview>;
  
  /**
   * Get the status of a mint instruction.
   * 
   * TODO: Implement status tracking:
   * - Query queue/database for instruction status
   * - Check on-chain status if executed
   * - Return current status with history
   * 
   * @param instructionId - Unique instruction ID
   * @returns Instruction with current status
   */
  getMintInstructionStatus(instructionId: string): Promise<AFIMintInstructionWithStatus | null>;
  
  /**
   * Cancel a queued mint instruction (if not yet executed).
   * 
   * TODO: Implement cancellation logic:
   * - Check if instruction is still queued
   * - Mark as rejected
   * - Notify backend/Safe
   * - Log to vault
   * 
   * @param instructionId - Unique instruction ID
   * @returns Whether cancellation was successful
   */
  cancelMintInstruction(instructionId: string): Promise<boolean>;
}

// ============================================================================
// Stub Implementation (for testing/scaffolding only)
// ============================================================================

/**
 * Stub implementation of AFIMintPipelineDriver.
 * 
 * This is a placeholder implementation that simulates queueing without
 * actually executing anything on-chain.
 * 
 * Future work will replace this with:
 * - Testnet: Staging backend or local mock
 * - Mainnet: Safe / backend / droid integration
 * 
 * @class StubMintPipelineDriver
 * @implements {AFIMintPipelineDriver}
 */
export class StubMintPipelineDriver implements AFIMintPipelineDriver {
  private queue: Map<string, AFIMintInstructionWithStatus> = new Map();
  
  async queueMintInstruction(instruction: AFIMintInstruction): Promise<AFIMintInstructionWithStatus> {
    console.log('[StubMintPipelineDriver] queueMintInstruction() called:', instruction);
    
    const withStatus: AFIMintInstructionWithStatus = {
      ...instruction,
      status: 'queued',
      statusHistory: [{
        status: 'queued',
        timestamp: new Date().toISOString(),
        note: 'Queued by stub implementation',
      }],
    };
    
    this.queue.set(instruction.instructionId, withStatus);
    return withStatus;
  }
  
  async previewMintImpact(instruction: AFIMintInstruction): Promise<AFIMintPreview> {
    console.log('[StubMintPipelineDriver] previewMintImpact() called:', instruction);
    
    // Stub preview - always returns valid
    return {
      instruction,
      exceedsSupplyCap: false,
      isValid: true,
      warnings: ['This is a stub implementation - no real validation performed'],
    };
  }
  
  async getMintInstructionStatus(instructionId: string): Promise<AFIMintInstructionWithStatus | null> {
    return this.queue.get(instructionId) || null;
  }
  
  async cancelMintInstruction(instructionId: string): Promise<boolean> {
    const instruction = this.queue.get(instructionId);
    if (!instruction || instruction.status !== 'queued') {
      return false;
    }
    
    instruction.status = 'rejected';
    instruction.statusHistory?.push({
      status: 'rejected',
      timestamp: new Date().toISOString(),
      note: 'Cancelled by user',
    });
    
    return true;
  }
}

